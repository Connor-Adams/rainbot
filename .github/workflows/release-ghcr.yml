name: Release Build Images (GHCR)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      force:
        description: "Force build (bypass CI + diff gating)"
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  packages: write
  checks: read

concurrency:
  group: ghcr-${{ github.ref }}
  cancel-in-progress: true

jobs:
  plan:
    name: Plan changed images
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      any: ${{ steps.set-matrix.outputs.any }}
      tag: ${{ steps.set-matrix.outputs.tag }}
      owner: ${{ steps.set-matrix.outputs.owner }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Repo info
        id: repo
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            core.setOutput('default_branch', data.default_branch);

      - name: Resolve tag SHA
        id: tag
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = context.payload.release?.tag_name;
            if (!tagName) {
              core.setFailed('Release tag not found in payload.');
              return;
            }
            const ref = `tags/${tagName}`;
            const { data: tagRef } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref,
            });
            core.setOutput('sha', tagRef.object.sha);

      - name: Verify tag on default branch (unless force)
        if: ${{ inputs.force != true }}
        run: |
          set -euo pipefail
          git fetch origin "${{ steps.repo.outputs.default_branch }}" --depth=200
          if ! git merge-base --is-ancestor "${{ steps.tag.outputs.sha }}" "origin/${{ steps.repo.outputs.default_branch }}"; then
            echo "Tag commit is not on default branch (${{
              steps.repo.outputs.default_branch
            }}). Refusing to build."
            exit 1
          fi

      - name: Verify CI status for tag (unless force)
        if: ${{ inputs.force != true }}
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ steps.tag.outputs.sha }}';
            const { data: status } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });
            const { data: checks } = await github.rest.checks.listSuitesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });
            const hasChecks = checks.total_count > 0;
            const hasStatuses = status.total_count > 0;
            if (!hasChecks && !hasStatuses) {
              core.warning(`No CI status or check suites found for ${sha}; continuing build.`);
              return;
            }
            const failedChecks = checks.check_suites.filter((s) => s.conclusion && s.conclusion !== 'success');
            if (failedChecks.length > 0) {
              core.setFailed(`CI checks not successful for ${sha}: ${failedChecks.map((s) => s.conclusion).join(', ')}`);
              return;
            }
            if (hasStatuses && status.state !== 'success') {
              core.setFailed(`Commit status is ${status.state} for ${sha}`);
            }

      - name: Compute changed services
        id: set-matrix
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          set -euo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            echo "GitHub CLI not found; falling back to git describe for previous tag."
          fi

          OWNER="${GITHUB_REPOSITORY_OWNER,,}"
          echo "owner=${OWNER}" >> "$GITHUB_OUTPUT"
          echo "tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"

          # Resolve tag ref
          if git rev-parse "${RELEASE_TAG}" >/dev/null 2>&1; then
            CURRENT_TAG="${RELEASE_TAG}"
          else
            CURRENT_TAG="refs/tags/${RELEASE_TAG}"
          fi

          PREV_TAG=""
          if command -v gh >/dev/null 2>&1; then
            if PREV_TAG_API=$(gh api repos/${GITHUB_REPOSITORY}/releases \
              --jq '.[] | select(.tag_name != env.RELEASE_TAG) | .tag_name' | head -n 1); then
              PREV_TAG="${PREV_TAG_API}"
            fi
          fi
          if [[ -z "${PREV_TAG}" ]]; then
            PREV_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null || true)
          fi

          # If no previous tag, build everything (first release)
          if [[ -z "${PREV_TAG}" ]]; then
            INC=""
            add() {
              local service="$1" image="$2" app_path="$3"
              if [[ -n "${INC}" ]]; then INC="${INC},"; fi
              INC="${INC}{\"service\":\"${service}\",\"image\":\"${image}\",\"app_path\":\"${app_path}\"}"
            }
            add "raincloud" "rainbot-raincloud" "apps/raincloud"
            add "rainbot" "rainbot-rainbot" "apps/rainbot"
            add "pranjeet" "rainbot-pranjeet" "apps/pranjeet"
            add "hungerbot" "rainbot-hungerbot" "apps/hungerbot"
            echo "matrix={\"include\":[${INC}]}" >> "$GITHUB_OUTPUT"
            echo "any=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          RANGE="${PREV_TAG}..${CURRENT_TAG}"
          echo "Diff range: ${RANGE}"

          changed() { git diff --name-only "${RANGE}" -- "$1" | grep -q .; }

          SHARED=false
          if changed "packages/" || changed "ui/" || changed "package.json" || changed "yarn.lock" || changed "turbo.json"; then
            SHARED=true
          fi

          # Build up a JSON matrix.include array
          INC=""

          add() {
            local service="$1" image="$2" app_path="$3"
            if [[ -n "${INC}" ]]; then INC="${INC},"; fi
            INC="${INC}{\"service\":\"${service}\",\"image\":\"${image}\",\"app_path\":\"${app_path}\"}"
          }

          # Adjust these paths to point to app directories with railway.json
          if [[ "${SHARED}" == "true" ]] || changed "apps/raincloud/"; then
            add "raincloud" "rainbot-raincloud" "apps/raincloud"
          fi

          if [[ "${SHARED}" == "true" ]] || changed "apps/rainbot/"; then
            add "rainbot" "rainbot-rainbot" "apps/rainbot"
          fi

          if [[ "${SHARED}" == "true" ]] || changed "apps/pranjeet/"; then
            add "pranjeet" "rainbot-pranjeet" "apps/pranjeet"
          fi

          if [[ "${SHARED}" == "true" ]] || changed "apps/hungerbot/"; then
            add "hungerbot" "rainbot-hungerbot" "apps/hungerbot"
          fi

          if [[ -z "${INC}" ]]; then
            echo 'matrix={"include":[]}' >> "$GITHUB_OUTPUT"
            echo "any=false" >> "$GITHUB_OUTPUT"
          else
            echo "matrix={\"include\":[${INC}]}" >> "$GITHUB_OUTPUT"
            echo "any=true" >> "$GITHUB_OUTPUT"
          fi

  build-and-push:
    name: Build & push changed images
    needs: [plan]
    if: ${{ needs.plan.outputs.any == 'true' }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4

      - name: Verify CI status for tag
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = context.payload.release.tag_name;
            const ref = `tags/${tagName}`;
            const { data: tagRef } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref,
            });
            const sha = tagRef.object.sha;
            const { data: status } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });
            const { data: checks } = await github.rest.checks.listSuitesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });
            const hasChecks = checks.total_count > 0;
            const hasStatuses = status.total_count > 0;
            if (!hasChecks && !hasStatuses) {
              core.warning(`No CI status or check suites found for ${sha}; continuing build.`);
              return;
            }
            const failedChecks = checks.check_suites.filter((s) => s.conclusion && s.conclusion !== 'success');
            if (failedChecks.length > 0) {
              core.setFailed(`CI checks not successful for ${sha}: ${failedChecks.map((s) => s.conclusion).join(', ')}`);
              return;
            }
            if (hasStatuses && status.state !== 'success') {
              core.setFailed(`Commit status is ${status.state} for ${sha}`);
            }

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Railpack
        run: |
          curl -sSL https://railpack.com/install.sh | sh
          railpack --version

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ needs.plan.outputs.owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build image with Railpack
        run: |
          IMAGE_TAG=${{ needs.plan.outputs.tag }}
          IMAGE_NAME="ghcr.io/${{ needs.plan.outputs.owner }}/${{ matrix.image }}"
          
          # Build image with railpack using the primary tag
          # Note: railpack will read railway.json from the app_path directory
          railpack build ${{ matrix.app_path }} \
            --name "${IMAGE_NAME}:${IMAGE_TAG}"

      - name: Tag images
        run: |
          IMAGE_TAG=${{ needs.plan.outputs.tag }}
          IMAGE_NAME="ghcr.io/${{ needs.plan.outputs.owner }}/${{ matrix.image }}"
          
          # Create additional prod tag
          docker tag "${IMAGE_NAME}:${IMAGE_TAG}" "${IMAGE_NAME}:prod"

      - name: Push images
        run: |
          IMAGE_NAME="ghcr.io/${{ needs.plan.outputs.owner }}/${{ matrix.image }}"
          docker push "${IMAGE_NAME}:${{ needs.plan.outputs.tag }}"
          docker push "${IMAGE_NAME}:prod"
