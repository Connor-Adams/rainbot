import express, { Application, Request, Response } from 'npm:express@4.19.2';
import { join } from '@std/path';
import { existsSync } from 'https://deno.land/std@0.224.0/fs/mod.ts';
import session from 'npm:express-session@1.18.0';
import FileStoreFactory from 'npm:session-file-store@1.5.0';
import passport from 'npm:passport@0.7.0';
import type { Client } from 'npm:discord.js@14.15.3';
import { createLogger } from '../utils/logger.ts';
import requestLogger from './middleware/requestLogger.ts';
import { setClient, getClient } from './client.ts';
import type { AppConfig } from '../types/server.ts';

const log = createLogger('SERVER');
const FileStore = FileStoreFactory(session);

// Try to load Redis (optional dependency)
let RedisStore: typeof import('npm:connect-redis@7.1.1').default | undefined;
let redis: typeof import('npm:redis@4.6.13') | undefined;
try {
  const redisLib = await import('npm:redis@4.6.13');
  const connectRedis = await import('npm:connect-redis@7.1.1');
  RedisStore = connectRedis.default;
  redis = redisLib;
} catch {
  // Redis not available, will use file store
  log.debug('Redis not available, will use file store for sessions');
}

export async function createServer(): Promise<Application> {
  const app = express();
  // Healthcheck endpoint for platform
  app.get('/health/live', (req: Request, res: Response) => {
    (res as any).status(200).type('text/plain').send('OK');
  });
  const { loadConfig } = await import('../utils/config.ts');
  const config: AppConfig = loadConfig() as AppConfig;

  // Trust proxy - required for Railway/Heroku/etc. to handle HTTPS properly
  // This enables correct handling of X-Forwarded-* headers
  const isRailway = !!Deno.env.get('RAILWAY_ENVIRONMENT') || !!Deno.env.get('RAILWAY_PUBLIC_DOMAIN');
  if (isRailway || Deno.env.get('NODE_ENV') === 'production') {
    app.set('trust proxy', 1);
    log.debug('Trust proxy enabled for production/Railway environment');
  }

  // Request logging
  app.use(requestLogger as any);

  // Session configuration
  // Prefer Redis for persistent sessions across deployments
  // IMPORTANT: Session secret must be consistent across deployments for sessions to persist
  const sessionSecret = config.sessionSecret;
  if (!sessionSecret || sessionSecret === 'change-this-secret-in-production') {
    log.error('⚠️  WARNING: SESSION_SECRET not set or using default value!');
    log.error(
      '⚠️  Sessions will NOT persist across deployments without a consistent SESSION_SECRET.'
    );
    log.error('⚠️  Set SESSION_SECRET environment variable to a secure random string.');
    log.error('⚠️  Generate one with: openssl rand -hex 32');
  } else {
    log.info('✓ SESSION_SECRET is configured (sessions will persist if secret stays consistent)');
  }

  let sessionStore: session.Store | undefined;
  // Try to get Redis URL from config or environment
  let redisUrl = config.redisUrl || Deno.env.get('REDIS_URL');

  // If REDIS_URL is not set, try to construct it from Railway's individual Redis env vars
  if (!redisUrl && Deno.env.get('REDISHOST')) {
    const redisHost = Deno.env.get('REDISHOST');
    const redisPort = Deno.env.get('REDISPORT') || '6379';
    const redisUser = Deno.env.get('REDISUSER') || '';
    const redisPassword = Deno.env.get('REDISPASSWORD') || '';

    // Construct Redis URL: redis://[username]:[password]@host:port
    if (redisPassword) {
      if (redisUser) {
        redisUrl = `redis://${redisUser}:${redisPassword}@${redisHost}:${redisPort}`;
      } else {
        redisUrl = `redis://:${redisPassword}@${redisHost}:${redisPort}`;
      }
    } else {
      redisUrl = `redis://${redisHost}:${redisPort}`;
    }

    log.info(
      '✓ Constructed Redis URL from Railway environment variables (REDISHOST, REDISPORT, etc.)'
    );
  }

  // Check if Redis is available
  if (!RedisStore || !redis) {
    log.warn('⚠️  Redis libraries not available - install redis package for persistent sessions');
  } else if (!redisUrl) {
    log.warn(
      '⚠️  Redis URL not configured - set REDIS_URL or Railway will auto-set it when Redis service is added'
    );
  }

  if (redisUrl && RedisStore && redis) {
    try {
      // Mask password in logs for security
      const maskedUrl = redisUrl.replace(/:[^:@]+@/, ':****@');
      log.debug(`Connecting to Redis: ${maskedUrl}`);

      // Create Redis client using URL (works for both Railway REDIS_URL and constructed URLs)
      const redisClient = redis.createClient({
        url: redisUrl,
        socket: {
          reconnectStrategy: (retries: number) => {
            if (retries > 10) {
              log.error('Redis connection failed after 10 retries, falling back to memory store');
              return false; // Stop retrying
            }
            return Math.min(retries * 100, 3000); // Exponential backoff, max 3s
          },
        },
      });

      // Redis event handlers (optional - for logging)
      // Note: Newer Redis client may not support these event handlers
      try {
        (redisClient as any).on?.('error', (err: Error) => {
          log.error(`Redis client error: ${err.message}`);
        });
        (redisClient as any).on?.('connect', () => {
          log.info('Redis client connected');
        });
        (redisClient as any).on?.('ready', () => {
          log.info('Redis client ready');
        });
      } catch (e) {
        // Ignore if event handlers are not supported
      }

      // Connect Redis client and wait for connection before creating store
      // connect-redis v7 requires the client to be connected before passing it to RedisStore
      try {
        await redisClient.connect();

        // Create Redis session store after connection is established
        sessionStore = new RedisStore({
          client: redisClient,
          prefix: 'rainbot:sess:',
          ttl: 7 * 24 * 60 * 60, // 7 days
        });

        log.info('✓ Using Redis for session storage (sessions will persist across deployments)');
      } catch (connectError) {
        const err = connectError as Error;
        log.warn(`Failed to connect to Redis: ${err.message}, falling back to memory store`);
        // Close the client if connection failed
        try {
          await redisClient.quit();
        } catch {
          // Ignore quit errors
        }
        sessionStore = undefined;
      }
    } catch (error) {
      const err = error as Error;
      log.warn(`Failed to initialize Redis store: ${err.message}, falling back to memory store`);
      sessionStore = undefined;
    }
  }

  // Fallback to memory store if Redis is not available
  // Note: Memory store does NOT persist across restarts, but is better than file store on Railway
  // For production, use Redis for persistent sessions
  if (!sessionStore) {
    if (isRailway || Deno.env.get('NODE_ENV') === 'production') {
      log.warn('⚠️  Using memory store for sessions (sessions will NOT persist across restarts)');
      log.warn('⚠️  For persistent sessions, configure REDIS_URL environment variable');
      // Use default memory store (no store specified)
      sessionStore = undefined;
    } else {
      // Local development: use file store
      try {
        sessionStore = new FileStore({
          path: config.sessionStorePath,
          ttl: 7 * 24 * 60 * 60, // 7 days
        });
        log.info(`✓ Using file store for sessions at ${config.sessionStorePath}`);
      } catch (error) {
        const err = error as Error;
        log.warn(`Failed to create file store: ${err.message}, using memory store`);
        sessionStore = undefined;
      }
    }
  }

  // Determine cookie security based on environment
  const useSecureCookies = Deno.env.get('NODE_ENV') === 'production' || isRailway;

  app.use(
    session({
      store: sessionStore,
      secret: sessionSecret || 'change-this-secret-in-production',
      resave: false,
      saveUninitialized: false,
      name: 'rainbot.sid', // Custom session name
      cookie: {
        httpOnly: true,
        secure: useSecureCookies, // Secure cookies on Railway/production
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
        sameSite: 'lax', // Allows cookies to be sent on top-level navigations
        // Don't set domain - let browser handle it (works better across subdomains)
      },
      rolling: true, // Reset expiration on activity (extends session on each request)
    }) as any
  );

  const storeType = sessionStore ? sessionStore.constructor.name : 'MemoryStore';
  log.info(
    `Session configured: store=${storeType}, secure=${useSecureCookies}, Railway=${isRailway}`
  );

  // Initialize Passport
  app.use(passport.initialize() as any);
  app.use(passport.session() as any);

  // Middleware
  app.use(express.json() as any);
  app.use(express.urlencoded({ extended: true }) as any);

  // Auth routes (must be before protected routes)
  const authRoutes = (await import('./routes/auth')).default;
  app.use('/auth', authRoutes);

  // API routes (must be before static files)
  const apiRoutes = (await import('./routes/api')).default;
  app.use('/api', apiRoutes);

  // Statistics routes
  const statsRoutes = (await import('./routes/stats')).default;
  app.use('/api/stats', statsRoutes);

  // Serve React build from ui/dist (production)
  // After TS compilation, __dirname is dist/server/, so go up 2 levels to reach project root
  const reactBuildPath = join(Deno.cwd(), 'ui', 'dist');

  if (existsSync(reactBuildPath)) {
    // Serve React build static assets
    app.use(express.static(reactBuildPath) as any);
    log.info('Serving React UI from ui/dist');
  } else {
    log.warn('React build not found at ui/dist. Run "npm run build:ui" to build the UI.');
  }

  // Serve React app for all other routes (SPA fallback)
  // IMPORTANT: Don't require auth here - let React app handle auth client-side
  // The React app will check auth via /auth/check API endpoint
  app.use((req: Request, res: Response): void => {
    // Skip if it's an API or auth route (shouldn't reach here, but safety check)
    const reqAny = req as any;
    if (reqAny.path.startsWith('/api/') || reqAny.path.startsWith('/auth/')) {
      (res as any).status(404).json({ error: 'Not found' });
      return;
    }
    // Serve React app (SPA fallback) - no auth required, React handles it
    const reactIndex = join(reactBuildPath, 'index.html');
    if (existsSync(reactIndex)) {
      (res as any).sendFile(reactIndex);
    } else {
      (res as any).status(503).send(`
                <html>
                    <body style="font-family: sans-serif; padding: 2rem; text-align: center;">
                        <h1>UI Not Built</h1>
                        <p>React UI has not been built yet.</p>
                        <p>Run: <code>npm run build:ui</code></p>
                    </body>
                </html>
            `);
    }
  });

  return app;
}

export async function start(client: Client, port = 3000): Promise<Application> {
  setClient(client);
  const app = await createServer();
  const { loadConfig } = await import('../utils/config');
  const config: AppConfig = loadConfig();

  // Railway and other platforms use 0.0.0.0 instead of localhost
  const host = Deno.env.get('HOST') || '0.0.0.0';

  app.listen(port, host, () => {
    const url = config.railwayPublicDomain
      ? `https://${config.railwayPublicDomain}`
      : `http://${host}:${port}`;
    log.info(`Dashboard running at ${url}`);
  });

  return app;
}

export { getClient };
